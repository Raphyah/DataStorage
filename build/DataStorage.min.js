"use strict";import{world,World,Entity,ItemStack}from"@minecraft/server";export class Compressor{static#list=[];#name;#compress;#decompress;constructor(compressorName){if(compressorName?.constructor!==String){throw new TypeError(`Compressor compressorName should be of type String, but instead ${compressorName?.constructor.name} was found`)}this.#name=compressorName;this.compressMethod=function(data){return data};this.decompressMethod=function(data){return data};Compressor.add(this)}get name(){return this.#name}set compressMethod(value){this.#compress=value}set decompressMethod(value){this.#decompress=value}compress(data){return this.#compress(data)}decompress(data){return this.#decompress(data)}static add(compressor){if(compressor.constructor!==Compressor){throw new TypeError(`Trying to add invalid compressor to Compressor.add(compressor)`)}if(this.#list.includes(compressor)){console.warn(`Compressor with name ${compressor.name} was not added due to already existing inside the list`);return false}if(this.find(compressor.name)){console.warn(`Compressor with name ${compressor.name} could not be added to the list due to the name being already in use`);return false}this.#list.push(compressor);return true}static find(value=this.default){const compressor=value?.constructor===Compressor?value:this.#list.find((x=>new RegExp(value).test(x.name)));return compressor}static#default;static set default(value){if(value.constructor!==Compressor){throw new TypeError(`Invalid compressor was set to Compressor.default`)}this.#default=value}static get default(){return this.#default}}const NO_COMPRESSION=new Compressor("none");Compressor.default=NO_COMPRESSION;export const ObjectNotation=function(){let defaultON;const obj={};Object.defineProperty(obj,"default",{get:function(){return defaultON},set:function(value){if(value?.constructor!==Object){throw new TypeError(`Default ObjectNotation should be of type Object, but instead ${value?.constructor.name} was found`)}if(value.parse?.constructor!==Function||value.stringify?.constructor!==Function){throw new SyntaxError(`Invalid ObjectNotation was found. parse/stringify functions are missing`)}defaultON=value}});obj.default=JSON;return obj}();const DEFAULT_SAFE_LENGTH=500;class CloneableMap extends Map{constructor(...args){super(...args)}clone(key){try{return JSON.parse(JSON.stringify(this.get(key)))}catch(err){console.error("Failed to deep clone a property")}}}export class DataStorage{#target;#compressor;#objectNotation;#safeLength;#loaded=false;constructor(target){if(!target instanceof World||!target instanceof Entity||!target instanceof ItemStack){throw new TypeError(`DataStorage target should be of type World, Entity or ItemStack, but instead ${target.constructor.name} was found`)}this.#target=target;this.compressor=Compressor.default;this.objectNotation=ObjectNotation.default;this.safeLength=DEFAULT_SAFE_LENGTH;Object.defineProperty(this,"data",{value:new CloneableMap})}get target(){return this.#target}set compressor(value){const compressor=Compressor.find(value);if(!compressor){throw new TypeError(`No valid compressor was provided to ${this.constructor.name}.prototype.compressor`)}this.#compressor=compressor}get compressor(){return this.#compressor}set objectNotation(value){if(value?.constructor!==Object){throw new TypeError(`'DataStorage.prototype.objectNotation' should be of type Object, but instead ${value?.constructor.name} was found`)}if(value.parse?.constructor!==Function||value.stringify?.constructor!==Function){throw new SyntaxError(`Invalid ObjectNotation was found. parse/stringify functions are missing`)}this.#objectNotation=value}get objectNotation(){return this.#objectNotation}set safeLength(value){if(value?.constructor!==Number){throw new TypeError(`${this.constructor.name}.prototype.safeLength should be of type Number, but instead ${value?.constructor.name} was found`)}this.#safeLength=value}get safeLength(){return this.#safeLength}save(){const keys=Object.keys(Object.fromEntries(this.data));for(const key of keys){const value=this.objectNotation.stringify(this.data.get(key));const data=this.compressor.compress(value);this.#saveRaw(key,data)}}#saveRaw(key,value){try{if(value.length<=this.safeLength){this.target.setDynamicProperty(key,value)}else{console.error("Data could not be assigned due to exceeding the safe limit defined")}}catch(error){console.error(error)}}load(){if(!this.#loaded){const keys=this.target.getDynamicPropertyIds();for(const key of keys){const value=this.#loadRaw(key);try{const data=this.compressor.decompress(value);this.data.set(key,this.objectNotation.parse(data))}catch(error){console.error(error)}}this.#loaded=true}return this.data}#loadRaw(key){return this.target.getDynamicProperty(key)}remove(key){if(this.data.has(key)){this.data.delete(key);this.target.setDynamicProperty(key,null);return true}return false}clear(){this.data.clear();this.target.clearDynamicProperties()}length(key){return this.#loadRaw(key)?.length||0}totalSize(){return this.target.getDynamicPropertyTotalByteCount()}}const property={get:function(){if(!this.__dataStorage__){this.__dataStorage__=new DataStorage(this)}return this.__dataStorage__}};if(!world.dataStorage){Object.defineProperty(world,"dataStorage",property)}if(!Entity.prototype.dataStorage){Object.defineProperty(Entity.prototype,"dataStorage",property)}if(ItemStack.prototype.setDynamicProperty&&ItemStack.prototype.getDynamicProperty&&!ItemStack.prototype.dataStorage){Object.defineProperty(ItemStack.prototype,"dataStorage",property)}