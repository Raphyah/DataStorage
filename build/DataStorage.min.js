"use strict";import{system,World,Entity,ItemStack}from"@minecraft/server";function BreakLoop(reason,status){this.reason=reason;this.exitStatus=status}const smoothLoop=(callback,map)=>new Promise((resolve=>{let iterable=map.entries();let lastReturned;function runLoop(){if(lastReturned&&lastReturned.constructor!==BreakLoop){const pair=iterable.next().value;if(pair){lastReturned=callback(...pair)}else{lastReturned=new BreakLoop("Iteration finished",0)}}if(lastReturned&&lastReturned.constructor!==BreakLoop){system.run(runLoop)}else{resolve(lastReturned)}}system.run(runLoop)}));export class Compressor{static#list=[];#name;#compress;#decompress;constructor(compressorName){if(compressorName?.constructor!==String){throw new TypeError(`Compressor compressorName should be of type String, but instead ${compressorName?.constructor.name} was found`)}this.#name=compressorName;this.compressMethod=function(data){return data};this.decompressMethod=function(data){return data};Compressor.add(this)}get name(){return this.#name}set compressMethod(value){this.#compress=value}set decompressMethod(value){this.#decompress=value}compress(data){return this.#compress(data)}decompress(data){return this.#decompress(data)}static add(compressor){if(compressor.constructor!==Compressor){throw new TypeError(`Trying to add invalid compressor to Compressor.add(compressor)`)}if(this.#list.includes(compressor)){console.warn(`Compressor with name ${compressor.name} was not added due to already existing inside the list`);return false}if(this.find(compressor.name)){console.warn(`Compressor with name ${compressor.name} could not be added to the list due to the name being already in use`);return false}this.#list.push(compressor);return true}static find(value=this.default){const compressor=value?.constructor===Compressor?value:this.#list.find((x=>new RegExp(value).test(x.name)));return compressor}static#default;static set default(value){if(value.constructor!==Compressor){throw new TypeError(`Invalid compressor was set to Compressor.default`)}this.#default=value}static get default(){return this.#default}}const NO_COMPRESSION=new Compressor("none");Compressor.default=NO_COMPRESSION;export class NotationHandler{static#list=[];#name;#parse;#stringify;constructor(notationName){if(notationName?.constructor!==String){throw new TypeError(`The 'notationName' parameter of 'NotationHandler' should be of type String, but instead ${notationName?.constructor.name} was found`)}this.#name=notationName;this.parseMethod=function(data){return data};this.stringifyMethod=function(data){return data}}get name(){return this.#name}set parseMethod(value){this.#parse=value}set stringifyMethod(value){this.#stringify=value}parse(...args){return this.#parse(...args)}stringify(...args){return this.#stringify(...args)}static add(notationHandler){if(notationHandler.constructor!==Compressor){throw new TypeError(`Trying to add invalid notation handler to Compressor.add(compressor)`)}if(this.#list.includes(notationHandler)){console.warn(`NotationHandler with name ${compressor.name} was not added due to already existing inside the list`);return false}if(this.find(notationHandler.name)){console.warn(`NotationHandler with name ${compressor.name} could not be added to the list due to the name being already in use`);return false}this.#list.push(notationHandler);return true}static find(value=this.default){const notationHandler=value?.constructor===NotationHandler?value:this.#list.find((x=>value===x.name));return notationHandler}static#default;static set default(value){if(value.constructor!==NotationHandler){throw new TypeError(`Invalid notation handler was set as default`)}this.#default=value}static get default(){return this.#default}}const JSON_NOTATION=new NotationHandler("json");JSON_NOTATION.parseMethod=JSON.parse;JSON_NOTATION.stringifyMethod=JSON.stringify;NotationHandler.default=JSON_NOTATION;const DEFAULT_SAFE_LENGTH=500;class CloneableMap extends Map{clone(key){try{return JSON.parse(JSON.stringify(this.get(key)))}catch(err){}}}export class DataStorage{#asynchronousSave=false;#synchronousSave=false;#target;#compressor;#notationHandler;#safeLength;#loaded=false;constructor(target){if(!target.setDynamicProperty||!target.getDynamicProperty){throw new TypeError(`DataStorage's 'target' must have support for dynamic properties, but ${target.constructor.name} doesn't provide said support`)}this.#target=target;this.compressor=Compressor.default;this.notationHandler=NotationHandler.default;this.safeLength=DEFAULT_SAFE_LENGTH;Object.defineProperty(this,"data",{value:new CloneableMap})}get target(){return this.#target}set compressor(value){const compressor=Compressor.find(value);if(!compressor){throw new TypeError(`No valid compressor was provided to 'DataStorage.prototype.compressor'`)}this.#compressor=compressor}get compressor(){return this.#compressor}set notationHandler(value){const notationHandler=NotationHandler.find(value);if(!notationHandler){throw new TypeError(`No valid notation handler was provided to 'DataStorage.prototype.notationHandler(value)'`)}this.#notationHandler=value}get notationHandler(){return this.#notationHandler}set safeLength(value){if(value?.constructor!==Number){throw new TypeError(`${this.constructor.name}.prototype.safeLength should be of type Number, but instead ${value?.constructor.name} was found`)}this.#safeLength=value}get safeLength(){return this.#safeLength}save(){if(this.#synchronousSave)return;this.#synchronousSave=true;for(const[key,value]of this.data.entries()){try{const data=this.compressor.compress(this.notationHandler.stringify(value));this.#saveRaw(key,data)}catch(err){console.error(err)}}this.#synchronousSave=false}saveAsync(){this.#asynchronousSave=true;smoothLoop(((value,key)=>{if(this.#synchronousSave)return new BreakLoop("Synchronous save process started",2);const data=this.compressor.compress(this.notationHandler.stringify(value));this.#saveRaw(key,data)}),this.data).catch(console.error).finally((()=>this.#asynchronousSave=false))}#saveRaw(key,value){try{if(value.length<=this.safeLength){this.target.setDynamicProperty(key,value)}else{console.error("Data could not be assigned due to exceeding the safe limit defined")}}catch(error){console.error(error)}}load(){if(!this.#loaded){const keys=this.target.getDynamicPropertyIds();for(let index=0;index<keys.length;index++){const key=keys[index];const value=this.#loadRaw(key);try{const data=this.compressor.decompress(value);this.data.set(key,this.notationHandler.parse(data))}catch(error){console.error(error)}}this.#loaded=true}return this.data}#loadRaw(key){return this.target.getDynamicProperty(key)}remove(key){if(this.data.has(key)){this.data.delete(key);this.target.setDynamicProperty(key,null);return true}return false}clear(){this.data.clear();this.target.clearDynamicProperties()}length(key){return this.#loadRaw(key)?.length||0}totalSize(){return this.target.getDynamicPropertyTotalByteCount()}}const property={get:function(){if(!this.__dataStorage__){this.__dataStorage__=new DataStorage(this)}return this.__dataStorage__}};if(!World.prototype.dataStorage){Object.defineProperty(World.prototype,"dataStorage",property)}if(!Entity.prototype.dataStorage){Object.defineProperty(Entity.prototype,"dataStorage",property)}if(ItemStack.prototype.setDynamicProperty&&ItemStack.prototype.getDynamicProperty&&!ItemStack.prototype.dataStorage){Object.defineProperty(ItemStack.prototype,"dataStorage",property)}